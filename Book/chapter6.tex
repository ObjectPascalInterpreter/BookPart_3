{\bfseries\slshape\sffamily\color{ChapterTitleColor} \chapter{Embedding Rhodus}} \label{chap:hosable}

\section{Introduction}

So far we'll seen Rhodus being used from a dedicated console terminal. What if someone wanted to use Rhodus from their own application? This short chapter will discuss that topic, that is embedding Rhodus in a host application.

There are various levels to which embedding can be done. The simplest, which we will discuss here, is to allow a host application to pass Rhodus scripts to the interpreter and retrieve the output. This is a fairly shallow form of embedding but the easiest to implement.

A more deeper embedding would allow a hosting application much more access to the internals of Rhodus and vice versa. Of particular interest would be the capacity to add extensions to Rhodus written in the hosting language. For example, if the hosting language were C, it might be useful to write performance critical computations (for example fast fourier transforms) in C and let Rhodus call out to those functions.

\section{Simple Embedding}

The simplest form of embedding is to provide the hosing application a series of API calls to allow the application to pass Rhodus scripts to the interpreter and retrieve the results. The API for this can be quite simple and in fact can be accomplished in just three API methods. Using C syntax, the three methods are given by:

\begin{lstlisting}
  intPtr_t rhodus_initialise (rhodusConfig *config);
  int      rhodus_run (intPtr_t handle, char* sourceCode);
  int      rhodus_terminate  (intPtr_t handle);
\end{lstlisting}

{\tt intPtr_t} is a C type introduced with C99 that is equivalent to the Delphi type {\tt NativeInt}.  Both types are signed integers but their size is equal to the size of a pointer on the current platform, be it 32 or 64-bit.

In Object Pascal format, the API methods are given by:

\begin{lstlisting}
  function  rhodus_initialise (var config : TRhodusConfig) : NativeInt;
  function  rhodus_run (handle : NativeInt; sourceCode : AnsiString) : integer;
  function  rhodus_terminate (handle : NativeInt) : integer;
\end{lstlisting}

In order that Rhodus can be called from any potential programming language, the interface API must be C compatible. For example, the lowest common denominator for handling strings is the humble {\tt char*}, that is a pointer to a null terminated array of byte characters (not unicode).

The three methods should be fairly easy to understand. We need to first initialise Rhodus using {\tt rhodus_initialise}, then call the Rhodus interpreter with a string containing the source code and finally terminate the session with {\tt rhodus_terminate}.

The initialization call will return a handle to the Rhodus interpreter. Internally this is a pointer to a Rhodus {\tt TRhodus} object. This handle must be used in subsequent calls to run and terminate. Multiple instances of Rhodus can be created in this way, one just needs to keep track of the handles. {\tt rhodus_terminate} will free up any memory used by the Rhodus interpreter.  

An important question is how to deal with output from the interpreter including error messages and output generated by the {\tt print} statements? Print output is host specific, e.g is it a terminal console or a GUI application? For this reason, we need a more generic way to handle such output. The easiest way to deal with output is to pass the Rhodus interpreter a callback. Internally we already do this, when the interpreter calls {\tt print}, it in turn calls a callback that will do the actual printing. The other thing to keep in mind is we can't just ask the host application to display a list or array since the host has no idea what the data types are. Instead, we will convert all output into a string form. That is we will represent whatever data type was asked to be output as a string. Displaying strings at the host is very generic and should be possible by almost any host.

Let's declare two callback signatures:

\begin{lstlisting}
void rhodus_print (char* astr);
void rhodus_println (char* astr);
\end{lstlisting}

One is for when {\tt print} is called and another for {\tt println} is called. We need some way to tell Rhodus about these. A convenient way to do this is to define a struct (i.e a record) that will include function pointers to the print methods. We'll define this, together with the function pointer declarations, using a C struct as:

\begin{lstlisting}
  void (*print)(char*);
  void (*println)(char*);

  typedef struct rhodus_config {
     print printptr;
     println printlnptr;
  } rhodus_config_t;
\end{lstlisting}

\begin{lstlisting}
void rhodus_print (char* astr);
void rhodus_println (char* astr);
\end{lstlisting}

We can create this struct and populate it with the function pointers. We then pass it to {\tt rhodus_initialize}. For example:

\begin{lstlisting}
void rhodus_print (char* msg)
{
  printf ("%s", msg);
}

void rhodus_println (char* msg)
{
  printf ("%s\n", msg);
}

void main() {
   rhodus_config_t *pConfig;
   intPtr_t handle;

   pConfig->print = rhodus_print;
   pConfig->println = rhodus_println;

   handle = rhodus_initialize (&pConfig);
}
\end{lstlisting}

We can use this to execute some code by using the following to lines:

\begin{lstlisting}
  rhodus_run (handle, "a = 4; b = 6; println (a + b)");
  rhodus_terminate (handle);
\end{lstlisting}

That deals without output from the {\tt print} functions, but what about error handling? What if there is a compiler or runtime error? You may have noticed that the method {\tt rhodus_run} returns an integer. The value of this integer determines success or failure. If {\tt rhodus_run} returns a negative integer, we have an error condition, otherwise the call was successful. This might seem a bit primitive compared to modern programming techniques such as exception handling.  The reason we can't use exception handling is that exceptions are very programming language specific and there is no way a hosting application would even understand how to deal with it. Most likely, if we were to raise an exception in Object Pascal inside a C host, the C host would likely crash. In general, exceptions should never attempt to propagate out of the Rhodus library when being used by a host. The safest way to deal with errors is by passing back error codes. We should therefore modify the above call to:

\begin{lstlisting}
  if (rhodus_run (handle, "a = 4; b = 6; println (a + b)") < 0)
     printf ("Error while calling rhodus interpreter\n");

  rhodus_terminate (handle);
\end{lstlisting}

How do we find out what kind of error it was? For this we need to add a forth API method called {\tt rhodus_getLastError()}. If there was an error, a call to this method will return a pointer to a struct (record) that contains the error message. The reason for using a struct is that in future we can expand the type of error information returned. The signature for this method is currently:

\begin{lstlisting}
  typedef struct rhodus_error {
      int errorCode;
      char* errorMsg;
  } rhodus_error_t;
\end{lstlisting}

The errorCode is not used at the moment. The signature for the {\tt rhodus_getLastError()} method is therefore:


\begin{lstlisting}
  rhodus_error_t* rhodus_getLastError();
\end{lstlisting}

We might use it this way:

\begin{lstlisting}
  if (rhodus_run (handle, "a = 4; b = 6; println (a + b)") < 0) {
     printf ("Error while calling rhodus interpreter:\n");
     printf ("\s\n", rhodus_getLastError().errorMsg);
  }

  rhodus_terminate (handle);
\end{lstlisting}

In Object Pascal the error record is defined as follows:

\begin{lstlisting}
  TRhodusError  = record
      errorCode : integer;
      errorMsg : PAnsiChar;
  end;
  PRhodusError = ^TRhodusError;
\end{lstlisting}  
  
We next come to one thorny little issue which is to do with memory ownership. The problem arises because the host application and the Rhodus library, operate completely separately when it comes to memory management. It's not possible for the host, perhaps a C based host, to free memory allocated by the Rhodus interpreter and vice versa. The key area of concern is string handling, particularly when returning string data back from the Rhodus library, for example {\tt rhodus_getLastError}. The string that this method returns was created within the Rhodus library and therefore the library owns the memory that was allocated for this error string. Under no circumstances must the host attempt to free this memory. If the host is C based, it might be tempting to free the string after use, don't, its not the host's memory to free. If it does attempt to free the string, the likely result is a crash.

Likewise, when the host passes the script string using {\tt rhodus_run}, that memory is owned by the host and the Rhodus library should not attempt to manipulate it. Instead the Rhodus library makes a copy and works with the copy where it has full ownership of the allotted memory.

The second issue to be aware of is that the Rhodus interpreter deals with Object Pascal strings, that is unicode, referenced counted strings. If your host is a C application, it will have no idea what this string type is. Instead, we again revert to the lowest common denominator by using {\tt char*} based strings. Luckily, Delphi makes it very easy to move back and forth between {\tt string} and {\tt char*}.

The final method I'd like to add to the API at this stage is a method we can use to get configuration information from the Rhodus interpreter. The signature for this method is given by:

\begin{lstlisting}
  rhodus_settings_t* rhodus_getSettings (int handle);
\end{lstlisting}

That is {\tt rhodus_getSettings } returns a pointer to a {\tt rhodus_settings_t} struct:

\begin{lstlisting}
  typedef struct rhodus_settings {
     char*  version;
  } rhodus_settings_t;
\end{lstlisting}

At the moment the only information available is the version for the current Rhodus interpreter. In C you'd use it like:

\begin{lstlisting}
  typedef struct rhodus_settings {
     char*  version;
  } rhodus_settings_t;

  rhodus_settings_t* pRhodusSettings;

  pRhodusSettings  = rhodus_getSettings (handle);
  printf ("version = %s\n", pRhodusSettings->version);
\end{lstlisting}

Last but not least, what is the Rhodus library itself?  Because the library is written in Object Pascal, the only viable option is to distribute the library as a sharable library, i.e dll (Windows), dylib (Mac), or .so library (Linux). We can't distribute the library as a static library because the object format that Delphi uses isn't compatible with other compilers.

\section{Rhodus Sharable Library}

Let's now look at the Rhodus library itself.

First of all the library will be in the for of a dll. We must therefore create a dll project in the Delphi IDE.  For those of you have never created a dll before this is quite straightforward. To start a new dll project, go to the File menu in the Delphi IDE and select New. In New you should see the option `Dynamic Library'. If not, select `Other' and look for the option there. Upon selection, you'll get a library file as shown below:

\begin{lstlisting}
library Project1;

uses
  System.SysUtils,
  System.Classes;

{$R *.res}

begin
end.
\end{lstlisting}

Note that I've remove a bunch off commenting that Delphi includes to save space. The only thing we need to do with this file is to specify what methods we would like to export from the dll. To do this we just add the keyword exports and the list of methods to export. For example:

\begin{lstlisting}
library librhodus;

uses
  System.SysUtils,
  System.Classes;

{$R *.res}

exports
    rhodus_initialize,
    rhodus_terminate,
    rhodus_run,
    rhodus_getLastError,
    rhodus_getSettings;

begin
end.
\end{lstlisting}

I've also renamed the project to {\tt librhodus}. This is all we have to do with the project file. The rest of the work involves implementing the methods we intend to export. We will implement these methods is a separate unit, which we will call {\tt uEmbeddAPI.pas}. The easiest method to implement is {\tt rhodus_terminate} method:

\begin{lstlisting}
function rhodus_terminate (handle : NativeInt) : integer; stdcall;
var rhodus : TRhodus;
begin
  try
    rhodus := TRhodus (handle);
    rhodus.free;
  except
    on e: Exception do
      begin
      lastErrorStr := e.Message;
      result := -1;
      end;
  end;
end;
\end{lstlisting}

The method signature uses {\tt NativeInt} which not everyone may be familiar with. We have to keep in mind that the library might be used as a 32-bit or 64-bit library. The argument called handle is a reference to a Rhodus object, i.e a pointer. On a 32-bit platform that size is 32-bit, whereas on a 64-bit platform the size is 64-bit. The argument type therefore needs to adapt to the particular platform. One way to do that is to use {\tt NativeInt} as the type because this integer is 32-bit on a 32-bit platform and 64-bit on a 64-bit platform.

The other major issue is if the caller passes in a handle that doesn't represent a reference to a Rhodus object. That has the potential to crash the system. There are a number of ways around this. One of the most robust methods is to maintain a dictionary of handles where the key is the ordinal value of the dictionary item. In this case the call doesn't pass a reference but an integer number. If that number isn't found in the dictionary, then it is an error, otherwise it uses the corresponding entry it finds as the Rhodus reference. This approach is much more important if we were building a python interface to {\tt librhodus}. Because python is user interactive, the user could literally pass anything as the handle. In this situation it is essential we insulate the Rhodus library from rogue handles and some kind of dictionary mechanism on the library side would be useful in this case. Of course we would also most likely create a Python class that would insulate a user from calling the library methods directly so that each instance of a Rhodus interpreter would be a separate instantiation of that class.

For now we will just wrap the code in an exception handler. I'm assuming that a call from a host application to the library will have a higher level of trust than a user typing python code. That means triggering the exception will be rare event and if it does happen its probably due to some other more serious issues.  Using an exception handle to hide bad inputs to the library call is not the best way to do it and I will likely return to this another time and implement a dictionary at the library end to completely insulate a user from having to deal with references at all.

The next method to look at is {\tt rhodus_initialize}.

\begin{lstlisting}
function rhodus_initialize (var config : TRhodusConfig) : NativeInt; stdcall
var rhodus : TRhodus;
begin
  try
    rhodus := TRhodus.Create;
    result := NativeInt (rhodus);

    rhodus.setPrintCallBack(config.printPtr);
    rhodus.setPrintLnCallBack(config.printlnPtr);
  except
    on e: Exception do
      begin
      lastErrorStr := e.Message;
      result := -1;
      end;
  end;
end;
\end{lstlisting}

The method returns a reference to a Rhodus object, hence we return a {\tt NativeInt} for reasons given previously. If you're calling this from C then I recommend declaring the method at the C end using {\tt intPtr_t} as its properties are the same as {\tt NativeInt}. We also wrap the code in an exception handler to ensure any errors are caught and are handled gracefully by returning a -1 to the caller. At this point you might be thinking why not return a {\tt nil} if a problem arises? We could and it is something that one often sees if a method returns a pointer but there has been an error. The reason why I'm using -1 instead is simply to remain consistent with the other methods that do return a -1 in the event of an error condition. This is a personal preference. It would be trvial to change it so that it returns {\tt nil} instead if there is a problem.

As well as returning an error condition, we also extract the exception message and store in a global record variable {\tt lastError} which we can retrieve afterwards using {\tt rhodus_get\-LastError}.

The other thing we do is copy the print function pointers from the config struct to Rhodus.

The most complicated method is {\tt rhodus_run}. This method must compile the code and run it. In each case we need to check for errors. In the event of an error we return -1 and copy the error message to the global variable {\tt lastError} which can be retrieved by {\tt rhodus_getlastError}.

We could make the running of scripts more sophisticated. For example, we could split the call into two, one call to compile and another to run. This would allow scripts to be precompiled and would make running scripts faster especially if the were called often,.

\begin{lstlisting}
function rhodus_run (handle : NativeInt; code : AnsiString) : integer; stdcall;
var rhodus : TRhodus;
    syntaxError : TSyntaxError;
    compilerError : TCompilerError;
begin
  result := 0;
  rhodus := TRhodus (handle);
  if rhodus.compileToAST (code, syntaxError) then
     begin
     if rhodus.generateByteCode (True, compilerError) then
        rhodus.runCode (mainModule, True)
     else
       begin
       lastErrorStr := 'ERROR ' + '[line ' + inttostr (compilerError.lineNumber)
                 + ', column: ' + inttostr (compilerError.columnNumber)
                 + '] ' + compilerError.errorMsg;
       result := -1;
       end;
     end
  else
     begin
     lastErrorStr := 'ERROR ' + '[line ' + inttostr (syntaxError.lineNumber)
                 + ', column: ' + inttostr (syntaxError.columnNumber)
                 + '] ' + syntaxError.errorMsg;
     result := -1;
     end;
end;
\end{lstlisting}

Last but not least, we must decide on the calling convention, at least for the 32-bit platform. For the 64-bit platform there is only one calling convention so we needn't worry about that platform. For the 32-bit platform there are a number of options, most notably, {\em cdecl} and {\em stdcall}. C generally follows the cdecl convention whereas the windows API uses stdcall. For our purpose it doesn't really matter which one we choose. What is important is that we make it clear which one we're using and that the caller must comply. If I'm writing a pure C application dll that will be called from C then I tend to use cdecl. For everything else one can use stdcall or cdecl. We'll use stdcall. In any event, we must decorate every exported method on the library side and every imported method on the host side with stdcall. For example:

\begin{lstlisting}
function rhodus_run (handle : NativeInt; code : AnsiString) : integer; stdcall;
\end{lstlisting}

%
%\section{Useful Reading}
%
%\subsection{Introductory Books}
%
%{\bf 1.} Ball, Thorsten. Writing A Compiler In Go. Thorsten Ball, 2018.
%
%{\bf 2.} Kernighan, Brian W.; Pike, Rob (1984). The Unix Programming Environment. Prentice-Hall. ISBN 0-13-937681-X.
%
%{\bf 3.} Nisan, Noam, and Shimon Schocken. The elements of computing systems: building a modern computer from first principles. MIT press, 2005.
%
%{\bf 4.} Parr, Terence. Language implementation patterns: create your own domain-specific and general programming languages. Pragmatic Bookshelf, 2009.
%
%\subsection{More Advanced Books}
%
%{\bf 1.} Jim Smith, Ravi Nair, Virtual Machines: Versatile Platforms for Systems and Processes, Morgan Kauffmann, June 2005
%
%{\bf 2.} Aho, Alfred V., Ravi Sethi, and Jeffrey D. Ullman. Compilers: Principles, Techniques and Tools (also known as The Red Dragon Book), 1986.
%
%\subsection{Source Code}
%
%{\bf 1.} Mak, Ronald. Writing compilers and interpreters: an applied approach/by Ronald Mark. 1991
%
%Note, this is the first edition, 1991. The code is in C, which I found to be understandable. The later editions that use C++ are not as clear. The issue I found is that the object orientated approach that's used tends to obscure the design principles of the interpreter and requires much study to decipher, The C version is much more straightforward.
%
%{\bf 2.} Wren: \url{https://github.com/wren-lang/wren}.\index{wren}
%
%Of the open source interpreters on GitHub, I found this to be the easiest to read. It's written by Bob Nystrom in C, the same person who is writing the web book: Crafting Interpreters \url{https://craftinginterpreters.com/}.
%
%{\bf 3.} Gravity: \index{Gravity} Another open source interpreter worth looking at is Gravity (\url{https://github.com/marcobambini/gravity}). Gravity, like Wren, is also written in C.
%
%{\bf 4.}  If you prefer Go,\index{Go} then the source code to look at is the interpreter written by Thorsten Ball (see book reference above).
%
%There are umpteen BASIC interpreters\index{BASIC} and other languages that can be studied.
%
%\bigskip\medskip

\begin{center}
\pgfornament[width = 8cm, color = cardinal]{83}
\end{center} 